"""Core orchestrator for coordinating agents and tasks."""

from __future__ import annotations

from collections import deque
from dataclasses import dataclass, field
from typing import Deque, Iterable

from multiagent_dev.agents.base import Agent, AgentMessage
from multiagent_dev.memory.memory import MemoryService


class OrchestratorError(RuntimeError):
    """Raised when orchestrator operations fail."""


@dataclass(frozen=True)
class UserTask:
    """Represents a high-level user task submitted to the system.

    Attributes:
        task_id: Unique identifier for the task.
        description: The user-provided task description.
        initial_agent_id: Agent that should receive the first message.
    """

    task_id: str
    description: str
    initial_agent_id: str = "planner"


@dataclass
class TaskResult:
    """Represents the result of running a task through the orchestrator.

    Attributes:
        task_id: Identifier of the executed task.
        completed: Whether the task completed successfully.
        messages_processed: Number of messages handled by the loop.
        history: All messages processed during the run.
    """

    task_id: str
    completed: bool
    messages_processed: int
    history: list[AgentMessage] = field(default_factory=list)


class Orchestrator:
    """Coordinates agents and routes messages between them."""

    def __init__(self, memory: MemoryService) -> None:
        """Initialize the orchestrator with shared services.

        Args:
            memory: Memory service for storing conversation history.
        """

        self._agents: dict[str, Agent] = {}
        self._memory = memory
        self._queue: Deque[AgentMessage] = deque()

    def register_agent(self, agent: Agent) -> None:
        """Register an agent with the orchestrator.

        Args:
            agent: The agent instance to register.
        """

        self._agents[agent.agent_id] = agent

    def get_agent(self, agent_id: str) -> Agent | None:
        """Retrieve a registered agent by ID."""

        return self._agents.get(agent_id)

    def send_message(self, message: AgentMessage) -> None:
        """Queue a message for delivery to an agent.

        Args:
            message: The message to enqueue.
        """

        self._queue.append(message)

    def _dispatch(self, message: AgentMessage) -> Iterable[AgentMessage]:
        """Dispatch a message to the appropriate agent.

        Args:
            message: The message to deliver.

        Returns:
            Messages generated by the receiving agent.

        Raises:
            OrchestratorError: If the recipient agent is not registered.
        """

        agent = self.get_agent(message.recipient)
        if agent is None:
            raise OrchestratorError(f"Unknown agent: {message.recipient}")
        return agent.handle_message(message)

    def run_task(self, task: UserTask, max_steps: int = 100) -> TaskResult:
        """Run a task by processing messages until completion.

        Args:
            task: The user task to execute.
            max_steps: Safety limit for message processing.

        Returns:
            Summary of the run including the message history.
        """

        initial_message = AgentMessage(
            sender="user",
            recipient=task.initial_agent_id,
            content=task.description,
        )
        self.send_message(initial_message)
        history: list[AgentMessage] = []
        processed = 0

        while self._queue and processed < max_steps:
            message = self._queue.popleft()
            history.append(message)
            self._memory.append_message(task.task_id, message)
            responses = self._dispatch(message)
            for response in responses:
                self.send_message(response)
            processed += 1

        completed = not self._queue
        return TaskResult(
            task_id=task.task_id,
            completed=completed,
            messages_processed=processed,
            history=history,
        )
